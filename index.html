
<!DOCTYPE html>

<html lang="en">
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

        <meta name="twitter:card" content="">
<meta name="twitter:site" content="@art101NFT">
<meta name="twitter:title" content="NFTChecker.io">
<meta name="twitter:description" content="Verify and Source NFT Metadata.">
<meta name="twitter:creator" content="@art101NFT">
<meta name="twitter:image" content="img/twitter.png">
<meta name="twitter:domain" content="https://NFTChecker.io">
        <meta property="og:type" content="NFTChecker.io">
        <meta property="og:title" content="NFTChecker - Verify and Source NFT Metadata." />
        <meta property="og:description" content="Verify and Source NFT Metadata." />
        <meta property="og:url" content="https://NFTChecker.io" />
        <meta property="og:image" content="https://NFTChecker.io/img/discord.png" />


        <meta charset="utf-8">
        <meta http-equiv="x-ua-compatible" content="ie=edge">
        <title>NFTChecker.io - Verify and Source NFT Metadata.</title>
    <meta name="Verify and Source NFT Metadata." co>
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <link rel="canonical" href="https://NFTChecker.io" />
        <link rel="apple-touch-icon" href="apple-touch-icon.png">
        <link rel="icon" href="favicon.ico" sizes="16x16" type="img/ico">
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/css/bootstrap.min.css" integrity="sha384-Gn5384xqQ1aoWXA+058RXPxPg6fy4IWvTNh0E263XmFcJlSAwiGgFAW/dAiS6JXm" crossorigin="anonymous">
        <link rel="stylesheet" href="css/normalize.css">
        <link rel="stylesheet" href="css/main.css">
        <link rel="preconnect" href="https://fonts.googleapis.com">
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@300;400;500;600;700&display=swap" rel="stylesheet">
        <script src="js/vendor/modernizr-2.8.3.min.js"></script>
        <script src="https://kit.fontawesome.com/25673ce6e4.js" crossorigin="anonymous"></script>
        <script async src="https://www.googletagmanager.com/gtag/js?id=G-1D24DTP8CK"></script>
        <script>
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-7TXTQCW5ZL');
        </script>
    </head>
<body>


<nav class="fixed-top">

<div class="container-fluid bg-transparent d-lg-none">
<div class="row justify-content-center align-items-center d-flex">
               <div class="col-6 text-left">

                    <a href="index.html"><img class="img-fluid" src="img/NFTChecker.svg" style="max-height: 3em;"></a>
                </div>


                <div class="col-6 text-right d-flex flex-wrap justify-content-around">

                    <a href="#howto"><img class="img-fluid" src="img/info.svg" style="max-height: 1.5em;"></a>
                    <a href="https://opensea.io/art101.eth?tab=created"><img class="img-fluid" src="img/opensea.svg" style="max-height: 1.5em;margin-left:2em;"></a>
                    <a href="https://twitter.com/Art101NFT"><img class="img-fluid" src="img/twitter.svg" style="max-height: 1.5em;margin-left:2em;"></a>





                </div>

</div>
</div>


<div class="container-fluid bg-transparent d-none d-lg-block">
<div class="row  align-items-center d-flex">
               <div class="col-6 text-left">

                    <a href="index.html"><img class="img-fluid" src="img/NFTChecker.svg" style="max-height: 2.5em;"></a>
                </div>

                <div class="col-6 text-right">
                    <a href="#howto"><img class="img-fluid" src="img/info.svg" style="max-height: 1.75em;"></a>
                    <a href="https://opensea.io/art101.eth?tab=created"><img class="img-fluid" src="img/opensea.svg" style="max-height: 1.75em;margin-left:2em;"></a>
                    <a href="https://patrn.me/"><img class="img-fluid" src="img/patrn.svg" style="max-height: 1.75em;margin-left:2em;"></a>

                    <a href="https://art101.io"><img class="img-fluid" src="img/Art101_Splash.svg" style="max-height: 1.75em;margin-left:2em;"></a>
                    <a href="https://twitter.com/Art101NFT"><img class="img-fluid" src="img/twitter.svg" style="max-height: 1.75em;margin-left:2em;"></a>





                </div>

</div>
</div>








</nav>





<div style="margin-top:96px"></div>




<div class="container-fluid bg-transparent">
<div class="row justify-content-center">
<div class="col-xs-12 col-sm-10 col-md-8 col-lg-6 col-lg-6">




<div id="input">
<div id="examples">





<div class="text-center">

<p>Select an $ETH NFT Collection and See How it Works.</p>

<button class="border-0 my-2 bg-transparent" data-contract="0xdc8bed466ee117ebff8ee84896d6acd42170d4bb" data-token="778" title="Contract:
0x62C1e9f6830098DFF647Ef78E1F39244258F7bF5
Token:
1234" style="color:#fbfbfb"><a href="#output"><img src="img/soup.png" class="rounded-circle" style="border:1px solid #231f20; max-height: 64px;" /></a></button>
<button class="border-0 my-2 bg-transparent" data-contract="0x7f81858ea3b43513adfaf0a20dc7b4c6ebe72919" data-token="400" title="Contract:
0x7f81858ea3b43513adfaf0a20dc7b4c6ebe72919
Token:
400" style="color:#fbfbfb"><a href="#output"><img src="img/mondrian.png" class="rounded-circle" style="border:1px solid #231f20; max-height: 64px;" /></a></button>
<button class="border-0 my-2 bg-transparent" data-contract="0x62c1e9f6830098dff647ef78e1f39244258f7bf5" data-token="1792" title="Contract:
0x62c1e9f6830098dff647ef78e1f39244258f7bf5
Token:
1792" style="color:#fbfbfb"><a href="#output"><img src="img/blocks.png" class="rounded-circle" style="border:1px solid #231f20; max-height: 64px;" /></a></button>
<button class="border-0 my-2 bg-transparent" data-contract="0xddf0aef52d9b3c2dc63ec120828a761a28103ba0" data-token="1" title="Contract:
0xddf0aef52d9b3c2dc63ec120828a761a28103ba0
Token:
1" style="color:#fbfbfb"><a href="#output"><img src="img/patrn.png" class="rounded-circle" style="border:1px solid #231f20; max-height: 64px;" /></a></button>

<button class="border-0 my-2 bg-transparent" data-contract="0xbc4ca0eda7647a8ab7c2061c2e118a18a936f13d" data-token="324" title="Contract:
0x495f947276749Ce646f68AC8c248420045cb7b5e
Token:
7474646574401184833521157869553608295992641394225252382269774205118327029761" style="color:#fbfbfb"><a href="#output"><img src="img/yacht.png" class="rounded-circle" style="border:1px solid #231f20; max-height: 64px;" /></a></button>


<button class="border-0 my-2 bg-transparent" data-contract="0x1a92f7381b9f03921564a437210bb9396471050c" data-token="1782" title="Contract:
0x1a92f7381b9f03921564a437210bb9396471050c
Token:
1782" style="color:#fbfbfb"><a href="#output"><img src="img/cats.png" class="rounded-circle" style="border:1px solid #231f20; max-height: 64px;" /></a></button>

<button class="border-0 my-2 bg-transparent" data-contract="0xb47e3cd837dDF8e4c57F05d70Ab865de6e193BBB" data-token="6529" title="Contract:
0xb47e3cd837dDF8e4c57F05d70Ab865de6e193BBB
Token:
6529" style="color:#fbfbfb"><a href="#output"><img src="img/punk.png" class="rounded-circle" style="border:1px solid #231f20; max-height: 64px;" /></a></button>

<button class="border-0 my-2 bg-transparent" data-contract="0xc92ceddfb8dd984a89fb494c376f9a48b999aafc" data-token="2146" title="Contract:
0xc92ceddfb8dd984a89fb494c376f9a48b999aafc
Token:
2146" style="color:#fbfbfb"><a href="#output"><img src="img/creature.jpg" class="rounded-circle" style="border:1px solid #231f20; max-height: 64px;" /></a></button>


<button class="border-0 my-2 bg-transparent" data-contract="0x8a90cab2b38dba80c64b7734e58ee1db38b8992e" data-token="1162" title="Contract:
0x8a90cab2b38dba80c64b7734e58ee1db38b8992e
Token:
1162" style="color:#fbfbfb"><a href="#output"><img src="img/doodle.jpg" class="rounded-circle" style="border:1px solid #231f20; max-height: 64px;" /></a></button>


<button class="border-0 my-2 bg-transparent" data-contract="0x3bf2922f4520a8ba0c2efc3d2a1539678dad5e9d" data-token="1162" title="Contract:
0x8a90cab2b38dba80c64b7734e58ee1db38b8992e
Token:
523" style="color:#fbfbfb"><a href="#output"><img src="img/force.png" class="rounded-circle" style="border:1px solid #231f20; max-height: 64px;" /></a></button>

<button class="border-0 my-2 bg-transparent" data-contract="0x60e4d786628fea6478f785a6d7e704777c86a7c6" data-token="1162" title="Contract:
0x60e4d786628fea6478f785a6d7e704777c86a7c6
Token:
7208" style="color:#fbfbfb"><a href="#output"><img src="img/mutant.png" class="rounded-circle" style="border:1px solid #231f20; max-height: 64px;" /></a></button>

<button class="border-0 my-2 bg-transparent" data-contract="0x8184a482a5038b124d933b779e0ea6e0fb72f54e" data-token="4792" title="Contract:
0x8184a482a5038b124d933b779e0ea6e0fb72f54e
Token:
4792" style="color:#fbfbfb"><a href="#output"><img src="img/wanderers.png" class="rounded-circle" style="border:1px solid #231f20; max-height: 64px;" /></a></button>

<button class="border-0 my-2 bg-transparent" data-contract="0x099689220846644f87d1137665cded7bf3422747" data-token="4792" title="Contract:
0x099689220846644f87d1137665cded7bf3422747
Token:
4998" style="color:#fbfbfb"><a href="#output"><img src="img/roboto.png" class="rounded-circle" style="border:1px solid #231f20; max-height: 64px;" /></a></button>


<button class="border-0 my-2 bg-transparent" data-contract="0xe785e82358879f061bc3dcac6f0444462d4b5330" data-token="4792" title="Contract:
0xe785e82358879f061bc3dcac6f0444462d4b5330
Token:
2576" style="color:#fbfbfb"><a href="#output"><img src="img/women.png" class="rounded-circle" style="border:1px solid #231f20; max-height: 64px;" /></a></button>


<button class="border-0 my-2 bg-transparent" data-contract="0x0c58ef43ff3032005e472cb5709f8908acb00205" data-token="41" title="Contract:
0x0c58ef43ff3032005e472cb5709f8908acb00205
Token:
41" style="color:#fbfbfb"><a href="#output"><img src="img/6529.png" class="rounded-circle" style="border:1px solid #231f20; max-height: 64px;" /></a></button>






</div>








</div>


<div style="margin-top:16px"></div>


<div id="nft_row" class="hide"><select id="nft_menu"></select></div>





<div class=""><label for="contract_field"><h5>Contract Address:&nbsp;<a href="#howto"><img class="img-fluid" src="img/info.svg" style="max-height: 1em;"></a></h5></label><br>


<input id="contract_field" size="1" minlength="100%" placeholder="0x0" class="w-100">
</div>


<div style="margin-top:16px"></div>


<div class=""><label for="token_field"><h5>TokenID:&nbsp;<a href="#howto"><img class="img-fluid" src="img/info.svg" style="max-height: 1em;"></a></h5></label><br>


<input id="token_field" size="1" placeholder="1234 or 0x4D2" class="w-100"></div>





<div>





<label style="display:none"><input id="remove_parsed" type="checkbox" checked="checked">Hide Parsed Metadata</label>



<span style="flex-grow: 1"></span>
<img id="arrows" class="hide" style="display:none;" src="NFT%20Resolver_files/arrows.png">



<button id="resolve_btn" class="w-100 border-0" style="margin-top: 16px;">Resolve</button>


</div>






</div>


<div style="margin-top:32px"></div>



<div id="output" style="border-radius:16px;">

</div>

</div>
</div>
</div>

<div class="container-fluid bg-transparent" id="howto">
<div class="row justify-content-center">
<div class="col-xs-12 col-sm-10 col-md-8 col-lg-6 col-lg-6 text-center">

<p>To check an NFT, you'll need its <b>contract address</b> and <b>tokenID</b>. If you're viewing the NFT on OpenSea, you can nab both from its URL.</p>

<img class="img-fluid" src="img/NFO.png" style="">

<p>https://opensea.io/assets/<span style="color:green">←Contract Address→</span>/<span style="color:red">←TokenID→</span></p>

</div>
</div>
</div>


<footer>

<div class="container-fluid bg-transparent">
<div class="row justify-content-center">
<div class="col-xs-12 col-sm-10 col-md-8 col-lg-6 col-lg-6 text-center">


<p>Created by <a href="https://twitter.com/adraffy">Raffy</a> w/ <a href="https://twitter.com/art101NFT">Art101</a></p>





<a href="https://patrn.me/"><img class="img-fluid" src="img/patrn.svg" style="max-height: 4em;margin-left:2em;"></a>


</div>
</div>
</div>

</footer>










































<script type="module">
import {smol_provider} from './smol-provider.js';
import {ABIDecoder} from './abi-decoder.js';

let resolve_aborter;
let smol = smol_provider('wss://mainnet.infura.io/ws/v3/d2feb3605f5348228f891965bca0dfec');
let urlParams = new URLSearchParams(window.location.search);

window.onload = function() {
  const resolve_btn = document.querySelector('#resolve_btn');
  const token_field = document.querySelector('#token_field');
  const contract_field = document.querySelector('#contract_field');
  const account_field = document.querySelector('#account_field');

  if (urlParams.has('contract') && urlParams.has('token')) {
    token_field.value = urlParams.get('token');
    contract_field.value = urlParams.get('contract');
    resolve();
  }
};

function unsigned_mod(x, d) {
	return (d + (x % d)) % d;
}

async function contract_supports_interface(async_request_provider, contract, type) {
	const SIG = '0x01ffc9a7' // sha3('supportsInterface(bytes4)')
	return ABIDecoder.from_hex(await async_request_provider({method: 'eth_call', params:[{to: contract, data: SIG + type.padEnd(64, '0')}, 'latest']})).number() > 0;
}

// if meta isn't returned
// get token url from each contract type
// fetch url, kinda expect json?
async function get_nft_info(async_request_provider, contract, token) {
	if (/^0xb47e3cd837dDF8e4c57F05d70Ab865de6e193BBB$/i.test(contract)) { // CryptoPunk
		return {
			contract_type: 'CryptoPunk',
			meta: {
				name: `CryptoPunk #${token}`,
				image: `https://www.larvalabs.com/public/images/cryptopunks/punk${token}.png`,
				external_url:  `https://www.larvalabs.com/cryptopunks/details/${token}`
			},
			supply: 10000
		};
	}
	let hex_token = BigInt(token).toString(16).padStart(64, '0');
	if (/^0x06012c8cf97bead5deae237070f9587f8e7a266d$/i.test(contract)) { // CryptoKitty
		/*
		let SIG = '0xe98b7f4d'; // getKitty(uint256)
		let meta_url = parse_abi_response(
			['bool', 'bool', 'uint256', 'uint256', 'uint256', 'uint256', 'uint256', 'uint256', 'uint256', 'uint256'])
			await async_request_provider({method: 'eth_call', params:[{to: contract, data: SIG + hex_token}, 'latest']})
		);
		return {contract_type: 'ERC-721', meta_url};
		*/
		throw new Error('TODO: CryptoKitty');
	}
	const SIG_tokenURI = '0xc87b56dd';	// tokenURI(uint256)
	if (await contract_supports_interface(async_request_provider, contract, '80ac58cd')) { // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md
		let dec = ABIDecoder.from_hex(await async_request_provider({method: 'eth_call', params:[{to: contract, data: SIG_tokenURI + hex_token}, 'latest']}));
		let meta_url = dec.string();
		return {contract_type: 'ERC-721', meta_url};
	} else if (await contract_supports_interface(async_request_provider, contract, 'd9b67a26')) { // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-1155.md
		const SIG = '0x0e89341c';	// uri(uint256)
		let dec = ABIDecoder.from_hex(await async_request_provider({method: 'eth_call', params:[{to: contract, data: SIG + hex_token}, 'latest']}));
		let meta_url = dec.string().replace(/{id}/, hex_token); // 1155 standard
		return {contract_type: 'ERC-1155', meta_url};
	} else if (await contract_supports_interface(async_request_provider, contract, 'd31b620d')) { // nonstandard 721
		// this is some kind of fucked up bullshit
		/* ['name()', 'symbol()', 'totalSupply()', 'balanceOf(address)',
			'ownerOf(uint256)', 'approve(address,uint256)',
			'safeTransferFrom(address,address,uint256)']
			.reduce((a, b) => a ^ BigInt(web3.utils.sha3(b)), 0n)
			.toString(16)
			.padStart(64, '0')
			.slice(0, 8) */
		let dec = ABIDecoder.from_hex(await async_request_provider({method: 'eth_call', params:[{to: contract, data: SIG_tokenURI + hex_token}, 'latest']}));
		let meta_url = dec.string();
		return {contract_type: 'ERC-721 (Fucked)', meta_url};
	} else {
		throw new Error(`Contract is not a known NFT: ${contract}`);
	}
}

const REGEX_ETH_ADDRESS = /^0x[0-9a-f]{40}$/i;
const REGEX_VIDEO_EXT = /\.(mp4|mov|avi|mkv|webm|wmv)$/i;

function unfuck_url(url) {
	// remove explicit ipfs
	let match;
	if (match = url.match(/\/ipfs\/(Qm[1-9a-zA-Z]{32,})(\/?.*)$/)) {
		url = `ipfs://${match[1]}${match[2]}`;
	}
	return url;
}

function replace_ipfs(url) {
	// some metadata is missing the ipfs protocol
	if (/^Qm[1-9a-zA-Z]{32,}$/.test(url)) {
		url = `ipfs://${url}`;
	}
	// replace ipfs protocol with http relay for browser support
	return url.replace(/^ipfs:\/\//, 'https://ipfs.io/ipfs/');
}

function upscale_image(img, n) {
	let canvas = document.createElement('canvas');
	let w = canvas.width = n * img.naturalWidth;
	let h = canvas.height = n * img.naturalHeight;
	let ctx = canvas.getContext('2d');
	ctx.imageSmoothingEnabled = false;
	ctx.drawImage(img, 0, 0, w, h);
	return canvas;
}

function format_dur(t) {
    if (t < 1000) return `${t|0} ms`;
    t /= 1000;
    if (t < 60) return `${t.toFixed(1)} sec`;
    t /= 60;
    return `${t.toFixed(1)} min`;
}

function add_duration(h, date0) {
    // put duration first so it wraps correctly
    h.innerHTML = `<span class="duration">${format_dur(new Date() - date0)}</span>${h.innerHTML}`;
}

function create_link(url) {
	let a = document.createElement('a');
	a.classList.add('bubble');
	a.href = url;
	a.target = '_blank';
	return a;
}



function step_token(delta) {
	let token = BigInt(token_field.value.trim()) + BigInt(delta);
	token_field.value = String(token < 0 ? 0 : token);
	resolve();
}

window.addEventListener('keydown', e => {
	switch (e.key) {
		case 'ArrowLeft': step_token(-1); break;
		case 'ArrowRight': step_token(1); break;
	}
	//console.log(e);
});
for (let f of [contract_field, token_field]) {
	f.addEventListener('keydown', e => {
		if (e.key == 'Enter') {
			e.stopPropagation();
			resolve();
		}
	});
}

for (let el of document.querySelectorAll('button[data-contract]')) {
	let {contract, token} = el.dataset;
	el.title = `Contract:\n${contract}\nToken:\n${token}`;
	el.addEventListener('click', () => {
    contract_field.value = contract;
    token_field.value = token;
    urlParams.set("contract", contract);
    urlParams.set("token", token);
    window.history.pushState('', '', '?' + urlParams.toString());
    resolve();
	});
}

resolve_btn.addEventListener('click', resolve);

async function get_async_provider() {
	if (typeof ethereum !== 'undefined' && parseInt(ethereum.chainId) == 1) { // dont force a swap
		// sometimes the browser wallet is pepega
		let {request} = ethereum;
		try {
			await request({method: 'eth_accounts'});
		} catch (err) {
			if (err.code === -32000) {
				await new Promise(ful => setTimeout(ful, 1000));
			} else {
				throw err;
			}
		}
		return request;
	} else {
		return smol;
	}
}

async function resolve() {
	if (resolve_btn.disabled) return;
	if (resolve_aborter) {
        resolve_aborter();
        await new Promise(ful => setTimeout(ful, 0));
    }
    let arrows = document.querySelector('#arrows');
    arrows.classList.remove('hide');
	await resolve0();
    arrows.classList.add('hide');
}

async function resolve0() {
  let start = new Date();

  let contract = contract_field.value.trim().toLowerCase();
  if (urlParams.has('contract')) {
    let contract = urlParams.get('contract');
  }

  let token = token_field.value.trim();
  if (urlParams.has('token')) {
    let token = urlParams.get('token');
  }

	let output = document.querySelector('#output');
	output.innerHTML = '';

	// lookup contract and get metadata whereabouts
	 let info;
	let pre_info = document.createElement('pre');
	pre_info.innerHTML = 'Connecting...';
	output.append(pre_info);
	try {
		resolve_btn.disabled = true;
		if (!REGEX_ETH_ADDRESS.test(contract)) {
			throw new Error('Contract should be an Ethereum address, in hex, starting with 0x.')
		}
		if (!/^\d+$/.test(token)) {
			throw new Error('Token should be an non-negative integer.');
		}
		pre_info.innerHTML = `Fetching contract ${contract}...`;
		info = await get_nft_info(await get_async_provider(), contract, token);
		/*
		try {
			info = await get_nft_info(async_request_provider, contract, token);
		} catch (err) {
			if (err.code !== -32000) throw err;
			pre_info.innerHTML = `Fetching contract ${contract} (again)...`;
			await new Promise(ful => setTimeout(ful, 1500)); // wait
			info = await get_nft_info(async_request_provider, contract, token);
		}
		*/
		pre_info.remove();
	} catch (err) {
		let {code, message} = err;
		pre_info.classList.add('error');
		if (code) {
			pre_info.innerHTML = `Ethereum error ${code}: ${message}`;
		} else {
			pre_info.innerHTML = message;
		}
		return;
	} finally {
		resolve_btn.disabled = false;
	}

	const ON_CHAIN = '✅ On-chain';

	let {contract_type, meta, meta_url} = info;

	let a_contract = create_link(`https://etherscan.io/address/${contract}`);
	a_contract.id = 'contract';
	a_contract.innerHTML = `<span class="duration">${format_dur(new Date() - start)}</span><b>${contract_type}:</b> <code>${contract}</code>`;
    a_contract.title = 'View contract on Etherscan';
	output.append(a_contract);

	// download meta if missing
	let pre_meta = document.createElement('pre');
	if (meta) {
		let h = document.createElement('div');
		h.classList.add('bubble', 'error');
		h.innerHTML = '<b>Implicit Metadata</b>';
		output.append(h, pre_meta);
	} else {
		try {
			if (!meta_url) throw new Error('Missing Metadata URL');
            let date0 = new Date();
			let url = unfuck_url(meta_url);
			let url_http = replace_ipfs(url);
			let h = create_link(url_http);
			if (url.startsWith('data:')) {
				h.innerHTML = `<b>Metadata:</b> ${ON_CHAIN}`;
			} else {
				h.innerHTML = `<b>Metadata:</b> ${url}`;
			}
			pre_meta.innerHTML = 'Fetching metadata...';
			output.append(h, pre_meta);
			let res;
			try {
				res = await fetch(url_http, {headers: {'Origin': window.location.hostname}});
			} catch (err) {
				// some devs forget to wild-card cors their metadata
				// which prevents client-run browser code from fetching
				// assume a failure is a cors-rejection and pass the
				// request through my server [note: not required]
				h.querySelector('b').innerHTML = 'Blocked Metadata:';
				h.classList.add('error');
				res = await fetch(`./relay.php?${url_http}`);
			}
			if (res.status != 200) throw new Error(`HTTP Error ${res.status}`);
			let text = await res.text();
			pre_meta.id = 'metadata';
            add_duration(h, date0);
			try {
				meta = JSON.parse(text);
				pre_meta.innerHTML = 'Parsing...';
			} catch (ignore) {
				h.querySelector('b').innerHTML = 'Malformed Metadata:';
				h.classList.add('error');
				pre_meta.innerHTML = text;
				return;
			}
		} catch (e) {
			pre_meta.classList.add('error');
			pre_meta.innerHTML = `Metadata fetch failed: ${e.message}`;
			return;
		}
	}

	// download assets (todo: support more stuff?)
	// https://docs.opensea.io/docs/metadata-standards

	let downloads = [];
    let value;

	let remove_parsed = document.querySelector('#remove_parsed').checked;
	function consume(key, test_fn) {
		let value = meta[key];
		let ok = test_fn(value);
		if (remove_parsed && (ok || value === null)) delete meta[key];
		if (ok) return value;
	}
	function consume_str(key) {
		return consume(key, x => typeof x === 'string');
	}

    let a_name = create_link(`https://opensea.io/assets/${contract}/${token}`);
    a_name.id = 'name';
	a_name.innerHTML = consume_str('name') ?? `Unnamed Token #${token}`;
    a_name.title = 'View asset on Opensea';
    a_contract.insertAdjacentElement('afterend', a_name); // insert name above metadata

	if (value = consume_str('description')) {
		let div = document.createElement('div');
		div.classList.add('bubble');
		div.id = 'desc';
		div.innerHTML = value;
		a_name.insertAdjacentElement('afterend', div); // insert description below name
	}

	value = consume_str('external_url');
	if (!value) consume_str('external_link');
	if (value) {
		let a = create_link(replace_ipfs(value));
		a.id = 'external';
		a.innerHTML = `<b>External Link:</b> ${value} &rarr;`;
		output.append(a);
	}

	// TODO: add support for properties
	if (value = consume('attributes', x => Array.isArray(x))) {
		let h = document.createElement('div');
		h.classList.add('bubble', 'header');
		h.innerHTML = ``;
		output.append(h);

		// TODO: add handler for birthday and other specials
		let grid = document.createElement('div');
		grid.id = 'attributes';
		for (let info of value.sort((a, b) => a)) {
			let {trait_type, value, display_type} = info;
			let div = document.createElement('div');
			let html = `<span class="value">${value}</span>`;
			if (trait_type) {
				html = `<span class="name">${trait_type}</span>${html}`;
			}
			if (display_type) {
				html = `${html}<span class="display>${display_type}</span>`;
			}
			div.innerHTML = html;
			grid.append(div);
		}
		output.append(grid);
	}

	// find the image
	let image_url = consume_str('image');
	if (!image_url) image_url = consume_str('imageUrl');

	// find the video
	let video_url = consume_str('animation_url');
	if (!video_url) { // check properties
		let {properties} = meta;
		if (properties) {
			for (let i = 1; ; i++) {
				let key = 'preview_media_file';
				if (i > 1) key = `${key}${i}`;
				let type = properties[`${key}_type`];
				if (!type) break; // last key
				if (!REGEX_VIDEO_EXT.test(`.${type.description}`)) continue; // not a video
				let val = properties[key];
				if (!val) continue; // wtf bro
				video_url = val.description;
				// todo: remove this if remove_parsed?
				break;
			}
		}
	}
	// some devs put videos as the image
	if (!video_url && REGEX_VIDEO_EXT.test(image_url)) {
		video_url = image_url;
		image_url = false;
	}
	if (video_url) {
        let date0 = new Date();
		let url = unfuck_url(video_url);
		let url_http = replace_ipfs(url);
        let h = create_link(url_http);
		h.innerHTML = `<b>Video:</b> ${url}`;
		output.append(h);
		let pre = document.createElement('pre');
		pre.innerHTML = 'Fetching video...';
		output.append(pre);
		let video = document.createElement('video');
		video.classList.add('asset');
		video.muted = true;
		video.autoplay = true;
		video.controls = true;
		//if (image_url) video.poster = image_url;
		output.append(video);
		downloads.push(new Promise(ful => {
			let source = document.createElement('source');
            function handle_error(e) {
                pre.classList.add('error');
				pre.innerHTML = `Fetch video failed: ${e.message ?? 'unknown reason (check browser console)'}`;
				console.error({video: url_http, error: e}); // wtf?
				video.remove();
				ful();
            }
            source.addEventListener('error', handle_error);
			video.addEventListener('canplay', () => {
                source.removeEventListener('error', handle_error);
				pre.remove();
                add_duration(h, date0);
                ful();
			});
			source.src = url_http;
			video.append(source);
		}));
	}

	/*
	if (value = consume_str('youtube_url')) {
		output.append(create_link(value, `<b>Youtube:</b> ${value}`));
		let frame = document.createElement('iframe');
		frame.classList.add('asset');
		frame.src = value;
		document.append(frame);
	}
	*/

	if (image_url) {
        let date0 = new Date();
		image_url = unfuck_url(image_url);
		let url_http = replace_ipfs(image_url);
        let h = create_link(url_http);
		if (image_url.startsWith('data:')) {
			h.innerHTML = `<b>Image:</b> ${ON_CHAIN}`;
		} else {
			h.innerHTML = `<b>Image:</b> ${image_url}`;
		}
		output.append(h);
		let pre = document.createElement('pre');
		pre.innerHTML = 'Fetching image...';
		output.append(pre);
		downloads.push(new Promise(ful => {
			let img = new Image();
			img.addEventListener('error', e => {
				pre.classList.add('error');
				pre.innerHTML = `Fetch image failed: ${e.message ?? 'Unknown reason'}`;
				ful();
			});
			img.addEventListener('load', () => {
				if (!pre.parentNode) return;
				img.classList.add('asset');
				pre.parentNode.replaceChild(img, pre);

				// append an upscaled version if tiny
				let {naturalWidth, naturalHeight} = img;
				if (Math.min(naturalWidth, naturalHeight) > 0) {

					let div = document.createElement('div');
					div.classList.add('dimensions');
					div.innerHTML = `${naturalWidth} x ${naturalHeight}`;
					img.insertAdjacentElement('beforebegin', div);
					//console.log(img);

					let max = Math.max(naturalWidth, naturalHeight);
					if (max < 128) {
						let canvas = upscale_image(img, (2048 / max)|0);
						canvas.classList.add('asset');
						img.insertAdjacentElement('afterend', canvas);
					}
				}
                add_duration(h, date0);
				ful();
			});
			img.src = url_http;
		}));
	} else if (value = consume_str('image_data')) { // TODO: find an example of this
		//output.append(create_link(http, `<b>Raw SVG Image</b> ${new Blob([].length} bytes`));
		let svg = document.createElement('svg');
		svg.classList.add('asset');
		svg.innerHTML = value;
		output.append(svg);
	}

	// dont show the metadata if we parsed all of it
	if (remove_parsed && Object.keys(meta).length == 0) {
		pre_meta.remove();
	} else {
		pre_meta.innerHTML = JSON.stringify(meta, null, 1);
	}

	// wait for downloads or abort
	await Promise.any([Promise.all(downloads), new Promise(ful => {
		resolve_aborter = ful;
	})]);
	resolve_aborter = undefined;
}
</script>

</body></html>
